package tasks

// Изменение значения через указатель
// Задача:
// Напиши функцию SetToZero(p *int), которая принимает указатель на int и устанавливает значение по этому адресу в 0.

func SetToZero(p *int){
	*p = 0
}

// Обмен значений через указатели
// Задача:
// Напиши функцию Swap(a, b *int), которая меняет местами значения по адресам a и b.

func Swap(a, b *int){
	temp := *a
	*a = *b
	*b = temp
}

// Функция, которая возвращает указатель на новую переменную
// Задача:
// Напиши функцию NewInt(val int) *int, которая возвращает указатель на новый int с заданным значением.

func NewInt(val int) *int{
	return &val
}
// ВНИМАНИЕ:
// Всё работает, но тут есть маленькая особенность!
// Когда ты возвращаешь адрес локальной переменной (val), Go всё делает правильно: она не исчезнет после выхода из функции, потому что компилятор сам перенесёт её в heap (а не в стек), если нужно.
// То есть это допустимо в Go.
// Но если ты когда-нибудь увидишь на собеседовании комментарии про "не возвращайте адрес локальной переменной" — знай, что в Go это безопасно.


// Изменить поле структуры по указателю
// Напиши функцию Birthday(p *Person), которая увеличивает возраст человека на 1.

func Birthday(p *Person){
	p.Age++
}

// Проверка, является ли указатель nil
// Задача:
// Напиши функцию IsNil(p *int) bool, которая возвращает true, если указатель равен nil.

func IsNil(p *int) bool{
	return p == nil
}